last_year <- last(sp500, "12 month")
# get end of year closing balance
end_of_year_balance <- max(last(last_year$AdjClose))
# get start of year closing balance
start_of_year_balance <- max(first(last_year$AdjClose))
# calculate the total return for the year
total_return <- (end_of_year_balance - start_of_year_balance) / start_of_year_balance
print(paste("The total return since last year is", round(total_return * 100, 2), "%"))
chartSeries(last_year,
type = "candlesticks", theme = "white",
name = paste("One Year S&P Index")
)
# plot the daily return movement during the last 12 month
ggplot(data = last_year, aes(x = index(last_year), y = round(daily_return * 100, 2))) +
geom_line(color = "darkgreen") +
labs(
y = "Daily Return", x = "Date",
title = "Daily Return Change in the Last 12 Month"
) +
geom_hline(yintercept = 0, linetype = "dashed", color = "red")
# Load the network.csv into R
network <- read.csv("network.csv")
# Sort k column in descending order before plotting
network <- network[order(network$k, decreasing = TRUE), ]
# plot the histogram of the degree (k) in ggplot2
hist_pot <- ggplot(data = network, aes(x = k)) +
geom_histogram(main = "Degree Distribution", binwidth = 3, fill = "lightblue", color = "blue") +
labs(
y = "Frequency", x = "Degree (k)",
title = "Degree Distribution"
)
line_ploy <- ggplot(data = network, aes(x = nodeid, y = k)) +
geom_line() +
labs(
y = "Degree (k)", x = "Node ID",
title = "Degree Distribution"
)
# combine histogram and line plot
grid.arrange(hist_pot, line_ploy, ncol = 1)
# y is a paramter whoese value is typically in the range 2 <y <3. In this example, we set the y = 2.5
y <- 2.5
# calculate P(k)
total_node <- nrow(network)
# calcualte P_k in the network dataset
network$P_k <- sapply(network$k, function(k) {
sum(network$k == k) / total_node
})
par(cex = 0.8)
plot(network$k, network$P_k, log = "xy", main = "Scale Free Network", xlab = "Degree (k)", ylab = "P(k)")
# Run the distplots.R script
source("distplots.r")
## we modify the original dist.table method to return the non-normalised data
dist.table_v2 <- function(d, response.var = ncol(d)) {
d <- scale(d) # scale data
d.dist <- dist(d[, -response.var]) # distance all X values
d.resp <- dist(d[, response.var])
# create a dataframe without normalisation
data.frame(cbind(d.dist, d.resp))
}
# Now construct the distance table
d1 <- dist.table_v2(ex1, response.var = 3)
# and plot it!
plot.dist.table(d1)
set.seed(123)
# create a dataset contains 1000 records that has no relationship between
# the explanatory and response variables
random_x <- rnorm(1000)
random_y <- rnorm(1000)
ex2 <- data.frame(x = random_x, y = random_y)
# plot the datasets
plot(ex2, pch = 1)
# Print out the x and y's standard deviation and mean
print(paste("The standard deviation of x is", round(sd(random_x), 2)))
print(paste("The standard deviation of y is", round(sd(random_y), 2)))
print(paste("The mean of x is", round(mean(random_x), 2)))
print(paste("The mean of y is", round(mean(random_y), 2)))
# Print out the x and y's correlation
print(paste("The correlation between x and y is", round(cor(random_x, random_y), 2)))
print(paste("The correlation between x and y is", round(cor(random_x, random_y), 2)))
# Read both Boston and bioavailability.txt data
library(MASS)
data(Boston)
df_bioavailability <- read.table("bioavailability.txt", sep = "\t", header = FALSE)
# Now construct the distance table
col_num <- dim(Boston)[2]
d <- dist.table(Boston, response.var = col_num)
# and plot it!
plot.dist.table(d)
title("Boston Dataset")
# Now construct the distance table
col_num <- dim(df_bioavailability)[2]
d <- dist.table(df_bioavailability, response.var = col_num)
# and plot it!
plot.dist.table(d)
title("Bioavailability Dataset")
df_countrystats <- read.csv("countrystats.csv")
# change the row name to countrystats column values
rownames(df_countrystats) <- df_countrystats[, 1]
# drop the countrystats column
df_countrystats <- df_countrystats[, -1]
# print each column name and its meaning
print(paste(
"The country stats data has", dim(df_countrystats)[1],
"rows and", dim(df_countrystats)[2],
"columns", "below is each folumn name and its meaning:"
))
print("Column names:")
print(colnames(df_countrystats))
print("The meaning of each variable for the countrystats data:")
print("Population Density: people per km2")
print("Income per Capita: $")
print("Purchasing Power Parity: $")
print("%change in GDP 2010-2011: %")
# apply the pca method to reduce the dimensionality of the data
pca_countrystats <- prcomp(df_countrystats, center = TRUE, scale = TRUE)
# plot the first two principal components
library(factoextra)
fviz_eig(pca_countrystats, addlabels = TRUE, main = "PCA of Country Stats")
library(EFAtools)
kmo <- KMO(df_countrystats)
print(paste("The KMO value of the df_countrystats dataset is:", round(kmo$KMO, 4)))
par(cex = 0.8)
biplot(pca_countrystats)
# take subset of countrystats_sub by only select IncomeperCapita,PopDensity
df_countrystats_sub <- df_countrystats[, c("IncomeperCapita", "PopDensity")]
# plot the data between IncomeperCapita and PopDensity
plot(df_countrystats_sub$IncomeperCapita, df_countrystats_sub$PopDensity,
pch = 20, col = "blue", main = "IncomeperCapita vs PopDensity",
xlab = "IncomeperCapita", ylab = "PopDensity"
)
# Change the plot that New Zealand is in red
points(df_countrystats_sub["NewZealand", ]$IncomeperCapita,
df_countrystats_sub["NewZealand", ]$PopDensity,
pch = 8, col = "red"
)
dist_to_nz <- data.frame(matrix(ncol = 2, nrow = 0))
colnames(dist_to_nz) <- c("country", "distance")
for (country_name in
rownames(
df_countrystats_sub[-which(rownames(df_countrystats_sub) == "NewZealand"), ]
)
) {
dist_to_nz <- rbind(
dist_to_nz,
data.frame(
country = country_name,
distance = dist(rbind(
df_countrystats_sub["NewZealand", ],
df_countrystats_sub[country_name, ]
))[1]
)
)
}
rownames(dist_to_nz)= dist_to_nz$country
dist_to_nz <- dist_to_nz[order(dist_to_nz$distance, decreasing = FALSE), ]
dist_to_nz <- subset(dist_to_nz, select = -country)
head(dist_to_nz, 5)
scaled_df_countrystats <- scale(df_countrystats)
par(cex = 0.6)
# plot_1 using average method. Showing the dendrogram by horizontal
plot(hclust(dist(scaled_df_countrystats), method = "average"),
main = "Hierarchical Clustering Dendrogram (Average Method)"
)
# plot_2 using complete method
par(cex = 0.6)
plot(hclust(dist(scaled_df_countrystats), method = "complete"),
main = "Hierarchical Clustering Dendrogram (Complete Method)"
)
# cut the dendrogram into 50 clusters
df_tree_50 <- data.frame(cutree(hclust(dist(scaled_df_countrystats),
method = "complete"
), k = 50))
nz_cluster_num <- df_tree_50[rownames(df_tree_50) == "NewZealand", ]
nz_cluster_country <- rownames(df_tree_50)[df_tree_50[, 1]
== nz_cluster_num & rownames(df_tree_50)
!= "NewZealand"]
df_dengrogram = data.frame(cluster=nz_cluster_num,country=nz_cluster_country)
print(paste("There are",nrow(df_dengrogram), "countries who are in the same cluster. The table below lists all countries."))
df_dengrogram
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
library(tsne)
# apply the t-SNE method to create a 2 dimensional plot of the country data
dist_countries <- dist(as.matrix(df_countrystats))
ecb <- function(x, y) {
plot(x, pch = 16, cex = 0.5)
text(x, labels = rownames(df_countrystats), cex = 0.5)
}
perplexity <- 5
# plot the result
tsne_countries <- tsne(dist_countries,
k = 2, perplexity = perplexity,
max_iter = 1000,
initial_dims = ncol(df_countrystats)
)
df_tsne_countries <- data.frame(tsne_countries)
rownames(df_tsne_countries) <- rownames(df_countrystats)
# create a datafram to store to store 5 nearnest countries to New Zealand by subsetting df_tsne_countries
dist_to_nz_tsne <- data.frame(matrix(ncol = 2, nrow = 0))
colnames(dist_to_nz_tsne) <- c("country", "distance")
for (country_name in rownames(
df_tsne_countries[-which(rownames(df_tsne_countries) == "NewZealand"), ]
)) {
dist_to_nz_tsne <- rbind(
dist_to_nz_tsne,
data.frame(
country = country_name,
distance = dist(rbind(
df_tsne_countries["NewZealand", ],
df_tsne_countries[country_name, ]
))[1]
)
)
}
# order the dist_to_nz_tsne in acending order and filter the top 5 distance
dist_to_nz_tsne <- dist_to_nz_tsne[order(dist_to_nz_tsne$distance, decreasing = FALSE), ]
par(cex = 0.8)
# Plot tsne_countries but colouring dist_to_nz_tsne countries in different color
plot(df_tsne_countries,
xlab = "", ylab = "",
pch = 19, cex = 0.5,
col = ifelse(rownames(df_tsne_countries) %in% dist_to_nz_tsne$country[1:5],
"blue", ifelse(rownames(df_tsne_countries) == "NewZealand",
"red", "lightblue"
)
)
)
# Print ledgends on different color plots
legend("bottom",
legend = c("New Zealand", "Top 5 nearest countries to New Zealand"),
col = c("red", "blue"), pch = 16
)
rownames(dist_to_nz_tsne) = dist_to_nz_tsne$country
dist_to_nz_tsne <- subset(dist_to_nz_tsne, select = -country)
head(dist_to_nz_tsne)
# Run the sp500.R script
source("sp500.r")
# subset the last one month of transactions
last_month <- last(sp500, "1 month")
chartSeries(last_month,
type = "candlesticks", theme = "white",
name = paste("One Month S&P Index")
)
library(ggplot2)
library("gridExtra")
# generate the price index line chart
plot_index <- ggplot(data = last_month, aes(x = index(last_month), y = AdjClose)) +
geom_line(color = "green") +
labs(
y = "Price Index", x = "Date",
title = "Price Index Change in the Last Month"
)
# title("Price Index and Transaction Volume in the Last Month")
# generate the transaction volume line chart
plot_volume <- ggplot(data = last_month, aes(
x = index(last_month),
y = Volume
)) +
geom_line(color = "blue") +
labs(
y = "Transaction Volume", x = "Date",
title = "Transaction Volume Change in the Last Month"
)
# title("Price Index and Transaction Volume in the Last Month")
# combine the two line chart
grid.arrange(plot_index, plot_volume, ncol = 1)
# Add Av(t) to the sp500 table
sp500$Av <- (sp500$Close + sp500$High + sp500$Low) / 3
#  Produce a single line plot showing Av(t) from sp500 table.
ggplot(data = sp500, aes(x = index(sp500), y = Av)) +
geom_line(color = "red") +
labs(
y = "Average Price", x = "Date",
title = "Average Price Change in the Last Month"
)
# add last day closing balance into  sp500 dataset
sp500$lastday_closing <- lag(sp500$AdjClose, 1)
# add daily return column into sp500 dataset
sp500$daily_return <- (sp500$AdjClose - sp500$lastday_closing) / sp500$lastday_closing
last_year <- last(sp500, "12 month")
# get end of year closing balance
end_of_year_balance <- max(last(last_year$AdjClose))
# get start of year closing balance
start_of_year_balance <- max(first(last_year$AdjClose))
# calculate the total return for the year
total_return <- (end_of_year_balance - start_of_year_balance) / start_of_year_balance
print(paste("The total return since last year is", round(total_return * 100, 2), "%"))
chartSeries(last_year,
type = "candlesticks", theme = "white",
name = paste("One Year S&P Index")
)
# plot the daily return movement during the last 12 month
ggplot(data = last_year, aes(x = index(last_year), y = round(daily_return * 100, 2))) +
geom_line(color = "darkgreen") +
labs(
y = "Daily Return", x = "Date",
title = "Daily Return Change in the Last 12 Month"
) +
geom_hline(yintercept = 0, linetype = "dashed", color = "red")
# Load the network.csv into R
network <- read.csv("network.csv")
# Sort k column in descending order before plotting
network <- network[order(network$k, decreasing = TRUE), ]
# plot the histogram of the degree (k) in ggplot2
hist_pot <- ggplot(data = network, aes(x = k)) +
geom_histogram(main = "Degree Distribution", binwidth = 3, fill = "lightblue", color = "blue") +
labs(
y = "Frequency", x = "Degree (k)",
title = "Degree Distribution"
)
line_ploy <- ggplot(data = network, aes(x = nodeid, y = k)) +
geom_line() +
labs(
y = "Degree (k)", x = "Node ID",
title = "Degree Distribution"
)
# combine histogram and line plot
grid.arrange(hist_pot, line_ploy, ncol = 1)
# y is a paramter whoese value is typically in the range 2 <y <3. In this example, we set the y = 2.5
y <- 2.5
# calculate P(k)
total_node <- nrow(network)
# calcualte P_k in the network dataset
network$P_k <- sapply(network$k, function(k) {
sum(network$k == k) / total_node
})
par(cex = 0.8)
plot(network$k, network$P_k, log = "xy", main = "Scale Free Network", xlab = "Degree (k)", ylab = "P(k)")
# Run the distplots.R script
source("distplots.r")
## we modify the original dist.table method to return the non-normalised data
dist.table_v2 <- function(d, response.var = ncol(d)) {
d <- scale(d) # scale data
d.dist <- dist(d[, -response.var]) # distance all X values
d.resp <- dist(d[, response.var])
# create a dataframe without normalisation
data.frame(cbind(d.dist, d.resp))
}
# Now construct the distance table
d1 <- dist.table_v2(ex1, response.var = 3)
# and plot it!
plot.dist.table(d1)
set.seed(123)
# create a dataset contains 1000 records that has no relationship between
# the explanatory and response variables
random_x <- rnorm(1000)
random_y <- rnorm(1000)
ex2 <- data.frame(x = random_x, y = random_y)
# plot the datasets
plot(ex2, pch = 1)
# Print out the x and y's standard deviation and mean
print(paste("The standard deviation of x is", round(sd(random_x), 2)))
print(paste("The standard deviation of y is", round(sd(random_y), 2)))
print(paste("The mean of x is", round(mean(random_x), 2)))
print(paste("The mean of y is", round(mean(random_y), 2)))
# Print out the x and y's correlation
print(paste("The correlation between x and y is", round(cor(random_x, random_y), 2)))
print(paste("The correlation between x and y is", round(cor(random_x, random_y), 2)))
# Read both Boston and bioavailability.txt data
library(MASS)
data(Boston)
df_bioavailability <- read.table("bioavailability.txt", sep = "\t", header = FALSE)
# Now construct the distance table
col_num <- dim(Boston)[2]
d <- dist.table(Boston, response.var = col_num)
# and plot it!
plot.dist.table(d)
title("Boston Dataset")
# Now construct the distance table
col_num <- dim(df_bioavailability)[2]
d <- dist.table(df_bioavailability, response.var = col_num)
# and plot it!
plot.dist.table(d)
title("Bioavailability Dataset")
df_countrystats <- read.csv("countrystats.csv")
# change the row name to countrystats column values
rownames(df_countrystats) <- df_countrystats[, 1]
# drop the countrystats column
df_countrystats <- df_countrystats[, -1]
# print each column name and its meaning
print(paste(
"The country stats data has", dim(df_countrystats)[1],
"rows and", dim(df_countrystats)[2],
"columns", "below is each folumn name and its meaning:"
))
print("Column names:")
print(colnames(df_countrystats))
print("The meaning of each variable for the countrystats data:")
print("Population Density: people per km2")
print("Income per Capita: $")
print("Purchasing Power Parity: $")
print("%change in GDP 2010-2011: %")
# apply the pca method to reduce the dimensionality of the data
pca_countrystats <- prcomp(df_countrystats, center = TRUE, scale = TRUE)
# plot the first two principal components
library(factoextra)
fviz_eig(pca_countrystats, addlabels = TRUE, main = "PCA of Country Stats")
library(EFAtools)
kmo <- KMO(df_countrystats)
print(paste("The KMO value of the df_countrystats dataset is:", round(kmo$KMO, 4)))
par(cex = 0.8)
biplot(pca_countrystats)
# take subset of countrystats_sub by only select IncomeperCapita,PopDensity
df_countrystats_sub <- df_countrystats[, c("IncomeperCapita", "PopDensity")]
# plot the data between IncomeperCapita and PopDensity
plot(df_countrystats_sub$IncomeperCapita, df_countrystats_sub$PopDensity,
pch = 20, col = "blue", main = "IncomeperCapita vs PopDensity",
xlab = "IncomeperCapita", ylab = "PopDensity"
)
# Change the plot that New Zealand is in red
points(df_countrystats_sub["NewZealand", ]$IncomeperCapita,
df_countrystats_sub["NewZealand", ]$PopDensity,
pch = 8, col = "red"
)
dist_to_nz <- data.frame(matrix(ncol = 2, nrow = 0))
colnames(dist_to_nz) <- c("country", "distance")
for (country_name in
rownames(
df_countrystats_sub[-which(rownames(df_countrystats_sub) == "NewZealand"), ]
)
) {
dist_to_nz <- rbind(
dist_to_nz,
data.frame(
country = country_name,
distance = dist(rbind(
df_countrystats_sub["NewZealand", ],
df_countrystats_sub[country_name, ]
))[1]
)
)
}
rownames(dist_to_nz)= dist_to_nz$country
dist_to_nz <- dist_to_nz[order(dist_to_nz$distance, decreasing = FALSE), ]
dist_to_nz <- subset(dist_to_nz, select = -country)
head(dist_to_nz, 5)
scaled_df_countrystats <- scale(df_countrystats)
par(cex = 0.6)
# plot_1 using average method. Showing the dendrogram by horizontal
plot(hclust(dist(scaled_df_countrystats), method = "average"),
main = "Hierarchical Clustering Dendrogram (Average Method)"
)
# plot_2 using complete method
par(cex = 0.6)
plot(hclust(dist(scaled_df_countrystats), method = "complete"),
main = "Hierarchical Clustering Dendrogram (Complete Method)"
)
# cut the dendrogram into 50 clusters
df_tree_50 <- data.frame(cutree(hclust(dist(scaled_df_countrystats),
method = "complete"
), k = 50))
nz_cluster_num <- df_tree_50[rownames(df_tree_50) == "NewZealand", ]
nz_cluster_country <- rownames(df_tree_50)[df_tree_50[, 1]
== nz_cluster_num & rownames(df_tree_50)
!= "NewZealand"]
df_dengrogram = data.frame(cluster=nz_cluster_num,country=nz_cluster_country)
print(paste("There are",nrow(df_dengrogram), "countries who are in the same cluster. The table below lists all countries."))
df_dengrogram
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
library(tsne)
# apply the t-SNE method to create a 2 dimensional plot of the country data
dist_countries <- dist(as.matrix(df_countrystats))
ecb <- function(x, y) {
plot(x, pch = 16, cex = 0.5)
text(x, labels = rownames(df_countrystats), cex = 0.5)
}
perplexity <- 5
# plot the result
tsne_countries <- tsne(dist_countries,
k = 2, perplexity = perplexity,
max_iter = 1000,
initial_dims = ncol(df_countrystats)
)
df_tsne_countries <- data.frame(tsne_countries)
rownames(df_tsne_countries) <- rownames(df_countrystats)
# create a datafram to store to store 5 nearnest countries to New Zealand by subsetting df_tsne_countries
dist_to_nz_tsne <- data.frame(matrix(ncol = 2, nrow = 0))
colnames(dist_to_nz_tsne) <- c("country", "distance")
for (country_name in rownames(
df_tsne_countries[-which(rownames(df_tsne_countries) == "NewZealand"), ]
)) {
dist_to_nz_tsne <- rbind(
dist_to_nz_tsne,
data.frame(
country = country_name,
distance = dist(rbind(
df_tsne_countries["NewZealand", ],
df_tsne_countries[country_name, ]
))[1]
)
)
}
# order the dist_to_nz_tsne in acending order and filter the top 5 distance
dist_to_nz_tsne <- dist_to_nz_tsne[order(dist_to_nz_tsne$distance, decreasing = FALSE), ]
par(cex = 0.8)
# Plot tsne_countries but colouring dist_to_nz_tsne countries in different color
plot(df_tsne_countries,
xlab = "", ylab = "",
pch = 19, cex = 0.5,
col = ifelse(rownames(df_tsne_countries) %in% dist_to_nz_tsne$country[1:5],
"blue", ifelse(rownames(df_tsne_countries) == "NewZealand",
"red", "lightblue"
)
)
)
# Print ledgends on different color plots
legend("bottom",
legend = c("New Zealand", "Top 5 nearest countries to New Zealand"),
col = c("red", "blue"), pch = 16
)
rownames(dist_to_nz_tsne) = dist_to_nz_tsne$country
dist_to_nz_tsne <- subset(dist_to_nz_tsne, select = -country)
head(dist_to_nz_tsne,5)
